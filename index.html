<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bhosale Family – Tree</title>
  <style>
    :root{
      --bg0:#060812;
      --bg1:#0a1340;
      --bg2:#0b2a7a;
      --ink:#eaf0ff;
      --muted:#a8b3d1;

      --card0: rgba(12, 16, 34, 0.78);
      --card1: rgba(20, 26, 54, 0.62);
      --stroke: rgba(255,255,255,0.12);

      --glow:#ffffff;
      --branch:#ffffff;
      --accent:#7c93ff;
      --accent2:#4ad0c7;

      --shadow: 0 14px 40px rgba(0,0,0,0.45);
      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background:
        radial-gradient(1200px 700px at 50% 10%, rgba(255,255,255,0.08), transparent 60%),
        radial-gradient(1200px 900px at 70% 30%, rgba(124,147,255,0.20), transparent 60%),
        radial-gradient(900px 700px at 20% 40%, rgba(74,208,199,0.12), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0) 55%);
      overflow:hidden;
    }

    header{
      position:fixed; top:0; left:0; right:0; z-index:30;
      padding:12px 14px;
      background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.12));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(10px);
    }
    .top{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      max-width: 1200px; margin:0 auto;
    }
    h1{
      margin:0;
      font-size: clamp(16px, 2.6vw, 20px);
      letter-spacing:0.3px;
      font-weight: 750;
    }
    .spacer{ flex:1; }

    .btn{
      background: rgba(10,14,30,0.65);
      color:var(--ink);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
      transition: transform 140ms ease, background 160ms ease, border-color 160ms ease;
    }
    .btn:hover{
      background: rgba(18,24,52,0.75);
      border-color: rgba(255,255,255,0.16);
    }
    .btn:active{ transform: translateY(1px) scale(0.99); }
    .btn.primary{
      border-color: rgba(124,147,255,0.40);
      box-shadow: 0 0 0 3px rgba(124,147,255,0.12);
    }
    .btn.danger{
      border-color: rgba(255,110,110,0.35);
      box-shadow: 0 0 0 3px rgba(255,110,110,0.10);
    }

    .search{
      display:flex; align-items:center; gap:8px;
      padding: 7px 10px;
      border-radius: 12px;
      background: rgba(10,14,30,0.60);
      border: 1px solid rgba(255,255,255,0.10);
      min-width: 260px;
    }
    .search input{
      border:0; outline:none; background:transparent; color:var(--ink);
      width: 100%;
      font-size: 13px;
    }

    .hint{
      font-size: 12px;
      color: var(--muted);
      opacity: 0.9;
      margin-left: 4px;
      white-space:nowrap;
    }
    .pill{
      font-size: 12px;
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.14);
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.18);
      white-space:nowrap;
    }

    /* VIEWPORT */
    .viewport{
      position:absolute;
      inset: 58px 0 0 0;
      overflow:hidden;
      cursor: grab;
    }
    .viewport:active{ cursor: grabbing; }

    /* Stage we pan/zoom */
    .stage{
      position:absolute;
      left:0; top:0;
      transform-origin: 0 0;
      will-change: transform;
    }

    /* SVG branches behind nodes */
    svg#branches{
      position:absolute;
      left:0; top:0;
      overflow: visible;
      pointer-events:none;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.35))
              drop-shadow(0 0 24px rgba(255,255,255,0.18));
    }
    .branch{
      fill:none;
      stroke: var(--branch);
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.95;
    }
    .trunk{
      fill:none;
      stroke: var(--branch);
      stroke-linecap: round;
      opacity: 0.95;
    }
    .spark{
      fill: rgba(255,255,255,0.95);
      opacity: 0.7;
    }

    /* Nodes */
    .node{
      position:absolute;
      width: 240px;
      padding: 12px 12px 10px;
      border-radius: var(--radius);
      background: linear-gradient(180deg, var(--card0), var(--card1));
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: var(--shadow), inset 0 1px 0 rgba(255,255,255,0.06);
      backdrop-filter: blur(6px);
      transform: translate(-50%, -50%);
      transition: box-shadow 180ms ease, transform 180ms ease, border-color 180ms ease;
      user-select:none;
    }
    .node:hover{
      border-color: rgba(124,147,255,0.35);
      box-shadow: 0 18px 60px rgba(0,0,0,0.55), 0 0 0 4px rgba(124,147,255,0.10);
    }
    .row{
      display:flex; align-items:flex-start; gap:10px;
    }
    .avatar{
      width: 36px; height: 36px;
      border-radius: 12px;
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,0.35), rgba(124,147,255,0.25)),
                  rgba(0,0,0,0.15);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.10);
      display:grid; place-items:center;
      flex: 0 0 auto;
    }
    .avatar svg{ opacity:0.9; }

    .title{
      display:flex; align-items:center; gap:8px; flex-wrap:wrap;
      font-weight: 780;
      letter-spacing:0.2px;
      line-height:1.2;
    }
    .tag{
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      color: var(--muted);
      background: rgba(0,0,0,0.18);
      font-weight: 650;
    }
    .sub{
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .node.match{
      outline: 2px solid rgba(74,208,199,0.75);
      box-shadow: 0 0 0 5px rgba(74,208,199,0.16), var(--shadow);
    }
    .node.selected{
      outline: 2px solid rgba(124,147,255,0.9);
      box-shadow: 0 0 0 5px rgba(124,147,255,0.18), var(--shadow);
    }

    /* Edit mode indicator */
    .editBadge{
      display:none;
      position: fixed;
      right: 14px; bottom: 14px;
      z-index: 40;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(124,147,255,0.18);
      border: 1px solid rgba(124,147,255,0.40);
      color: var(--ink);
      font-size: 12px;
      backdrop-filter: blur(8px);
    }
    body.editing .editBadge{ display:block; }
    body.editing .node{ cursor: pointer; }
    body.editing .node:hover{
      transform: translate(-50%, -50%) scale(1.02);
    }

    /* Small modal */
    .modalWrap{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      z-index: 60;
      padding: 18px;
    }
    .modal{
      width: min(560px, 100%);
      border-radius: 18px;
      background: rgba(10,14,30,0.88);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: 0 20px 80px rgba(0,0,0,0.6);
      padding: 14px;
    }
    .modal h2{
      margin: 2px 4px 10px;
      font-size: 16px;
      font-weight: 780;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      padding: 6px 4px;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    label{
      font-size: 12px;
      color: var(--muted);
    }
    input, select, textarea{
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--ink);
      border-radius: 12px;
      padding: 10px 10px;
      outline:none;
      font-size: 13px;
    }
    textarea{ min-height: 70px; resize: vertical; }
    .modalActions{
      display:flex;
      gap: 10px;
      justify-content:flex-end;
      padding: 10px 4px 4px;
      flex-wrap: wrap;
    }
    .modalNote{
      margin: 8px 4px 0;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    @media (max-width: 720px){
      .search{ min-width: 200px; }
      .grid{ grid-template-columns: 1fr; }
      .node{ width: 230px; }
      .hint{ display:none; }
    }
  </style>
</head>
<body>
  <header>
    <div class="top">
      <h1>Bhosale Family – Tree</h1>

      <div class="search" title="Type to find names. Enter jumps to next match. Esc clears.">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M21 21l-4.2-4.2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          <circle cx="11" cy="11" r="7" stroke="currentColor" stroke-width="2"/>
        </svg>
        <input id="search" placeholder="Search names…" />
      </div>

      <span class="hint">Drag to move • Wheel to zoom</span>

      <div class="spacer"></div>

      <button class="btn" id="fit">Fit</button>
      <button class="btn" id="zoomOut">–</button>
      <button class="btn" id="zoomIn">+</button>
      <button class="btn primary" id="toggleEdit">Edit Mode: OFF</button>
      <button class="btn" id="exportBtn">Export</button>
      <button class="btn" id="importBtn">Import</button>
      <span class="pill" id="saveState">Saved locally</span>
    </div>
  </header>

  <div class="viewport" id="viewport" aria-label="Tree viewport">
    <div class="stage" id="stage">
      <svg id="branches"></svg>
      <div id="nodesLayer"></div>
    </div>
  </div>

  <div class="editBadge">Edit Mode is ON • Click a person to edit</div>

  <!-- Modal -->
  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true">
    <div class="modal">
      <h2 id="modalTitle">Edit Person</h2>
      <div class="grid">
        <div class="field">
          <label>Name</label>
          <input id="mName" />
        </div>
        <div class="field">
          <label>Tag / Role</label>
          <input id="mTag" placeholder="e.g., Grandparents / Child / Grandchild" />
        </div>
        <div class="field">
          <label>Notes (optional)</label>
          <textarea id="mNotes" placeholder="Any small note (city, year, etc.)"></textarea>
        </div>
        <div class="field">
          <label>Actions</label>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button class="btn" id="mAddChild">Add child</button>
            <button class="btn danger" id="mDelete">Delete</button>
          </div>
        </div>
      </div>

      <div class="modalActions">
        <button class="btn" id="mCancel">Cancel</button>
        <button class="btn primary" id="mSave">Save</button>
      </div>

      <div class="modalNote">
        Tip: This saves to <b>localStorage</b> in this browser. Use Export if you want to move it to another device.
      </div>
    </div>
  </div>

  <script>
    /***********************
     * 1) TREE DATA (JSON)
     ***********************/
    const DEFAULT_DATA = {
      id: uid(),
      name: "Bhahusaheb Bhosale & Vasanti Bhosale",
      tag: "Grandparents",
      notes: "",
      children: [
        { id: uid(), name: "Anil Bhosale", tag: "Child", notes: "", children: [
          { id: uid(), name: "Tejaswini Bhosale", tag: "Grandchild", notes: "", children: [] },
          { id: uid(), name: "Shweta Bhosale", tag: "Grandchild", notes: "", children: [] },
          { id: uid(), name: "Atharva Bhosale", tag: "Grandchild", notes: "", children: [] },
        ]},
        { id: uid(), name: "Satish Bhosale", tag: "Child", notes: "", children: [
          { id: uid(), name: "Aryan Bhosale", tag: "Grandchild", notes: "", children: [] },
        ]},
        { id: uid(), name: "Manish Bhosale", tag: "Child", notes: "", children: [
          { id: uid(), name: "Swanandi Bhosale", tag: "Grandchild", notes: "", children: [] },
        ]},
        { id: uid(), name: "Girish Bhosale", tag: "Child", notes: "", children: [
          { id: uid(), name: "Krish Bhosale", tag: "Grandchild", notes: "", children: [] },
          { id: uid(), name: "Parth Bhosale", tag: "Grandchild", notes: "", children: [] },
        ]},
      ]
    };

    function uid(){
      return Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
    }

    const STORAGE_KEY = "bhosale_tree_v2";
    function loadData(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return structuredClone(DEFAULT_DATA);
        const parsed = JSON.parse(raw);
        return sanitizeTree(parsed);
      }catch{
        return structuredClone(DEFAULT_DATA);
      }
    }
    function saveData(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(treeData));
      setSaveBadge("Saved locally");
    }
    function sanitizeTree(node){
      // Ensure minimum fields exist
      const n = {
        id: node.id || uid(),
        name: node.name || "Unnamed",
        tag: node.tag || "",
        notes: node.notes || "",
        children: Array.isArray(node.children) ? node.children.map(sanitizeTree) : []
      };
      return n;
    }

    let treeData = loadData();

    /***********************
     * 2) LAYOUT ENGINE
     *    - places nodes like a real tree
     ***********************/
    const CFG = {
      levelY: 160,      // vertical distance per generation
      gapX: 42,         // horizontal gap between sibling blocks
      nodeW: 240,
      nodeH: 84,
      padX: 90,         // outer padding
      padY: 120,
    };

    // We'll compute subtree widths so that larger subtrees get more horizontal space.
    function computeSubtree(node){
      const kids = node.children || [];
      const childLayouts = kids.map(computeSubtree);

      const selfWidth = CFG.nodeW;
      const kidsWidth = childLayouts.length
        ? childLayouts.reduce((s,c)=>s + c.width, 0) + CFG.gapX * (childLayouts.length - 1)
        : 0;

      const width = Math.max(selfWidth, kidsWidth);
      return { node, children: childLayouts, width };
    }

    // Assign x,y positions, centered by subtree width
    function assignPositions(layout, depth, leftX){
      const xCenter = leftX + layout.width / 2;
      layout.x = xCenter;
      layout.y = depth * CFG.levelY;

      // children distributed within the subtree block
      const kids = layout.children;
      if(kids.length){
        const kidsTotal = kids.reduce((s,c)=>s + c.width, 0) + CFG.gapX * (kids.length - 1);
        let cursor = leftX + (layout.width - kidsTotal)/2;
        for(const child of kids){
          assignPositions(child, depth + 1, cursor);
          cursor += child.width + CFG.gapX;
        }
      }
      return layout;
    }

    function flatten(layout, arr=[]){
      arr.push(layout);
      for(const c of layout.children) flatten(c, arr);
      return arr;
    }

    /***********************
     * 3) RENDER
     ***********************/
    const stage = document.getElementById("stage");
    const nodesLayer = document.getElementById("nodesLayer");
    const branchesSvg = document.getElementById("branches");

    function render(){
      // layout
      const L0 = computeSubtree(treeData);
      const L = assignPositions(L0, 0, 0);
      const nodes = flatten(L);

      // compute bounds
      let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
      for(const n of nodes){
        minX = Math.min(minX, n.x);
        maxX = Math.max(maxX, n.x);
        maxY = Math.max(maxY, n.y);
      }
      const width = (maxX - minX) + CFG.nodeW + CFG.padX*2;
      const height = (maxY) + CFG.nodeH + CFG.padY*2;

      // stage size
      stage.style.width = width + "px";
      stage.style.height = height + "px";

      // render SVG branches
      branchesSvg.setAttribute("width", width);
      branchesSvg.setAttribute("height", height);
      branchesSvg.setAttribute("viewBox", `0 0 ${width} ${height}`);
      branchesSvg.innerHTML = makeBranchesSvg(nodes, minX);

      // render node divs
      nodesLayer.innerHTML = "";
      for(const item of nodes){
        const n = item.node;
        const el = document.createElement("div");
        el.className = "node";
        el.dataset.id = n.id;

        const x = (item.x - minX) + CFG.padX;
        const y = (item.y) + CFG.padY;

        el.style.left = x + "px";
        el.style.top  = y + "px";

        el.innerHTML = `
          <div class="row">
            <div class="avatar" aria-hidden="true" title="Person">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                <path d="M20 21a8 8 0 0 0-16 0" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                <circle cx="12" cy="8" r="4" stroke="currentColor" stroke-width="2"/>
              </svg>
            </div>
            <div style="flex:1; min-width:0;">
              <div class="title">
                <span class="nameText">${escapeHtml(n.name)}</span>
                ${n.tag ? `<span class="tag">${escapeHtml(n.tag)}</span>` : ``}
              </div>
              ${n.notes ? `<div class="sub">${escapeHtml(n.notes)}</div>` : `<div class="sub"> </div>`}
            </div>
          </div>
        `;

        // click behavior
        el.addEventListener("click", (e)=>{
          e.stopPropagation();
          if(editMode){
            openModal(n.id);
          }
        });

        nodesLayer.appendChild(el);
      }

      // keep search highlighting consistent after re-render
      applySearchHighlight(currentSearch);
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, m => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[m]));
    }

    function makeBranchesSvg(nodes, minX){
      // Curvy branches from parent to child (behind nodes)
      // We'll also draw a thicker "trunk-ish" path down from the root for the vibe.
      const byId = new Map(nodes.map(n => [n.node.id, n]));
      const paths = [];

      // glow defs
      const defs = `
        <defs>
          <filter id="glow" x="-40%" y="-40%" width="180%" height="180%">
            <feGaussianBlur stdDeviation="3.2" result="blur"/>
            <feMerge>
              <feMergeNode in="blur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
          <filter id="softGlow" x="-40%" y="-40%" width="180%" height="180%">
            <feGaussianBlur stdDeviation="6.5" result="blur"/>
            <feMerge>
              <feMergeNode in="blur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>
      `;

      const root = nodes[0];
      const rootX = (root.x - minX) + CFG.padX;
      const rootY = root.y + CFG.padY;

      // trunk (downwards a bit)
      const trunkTop = rootY - 80;
      const trunkBottom = rootY + 110;
      paths.push(`
        <path class="trunk" filter="url(#softGlow)"
          d="M ${rootX} ${trunkTop}
             C ${rootX+2} ${trunkTop+40}, ${rootX-2} ${trunkBottom-40}, ${rootX} ${trunkBottom}"
          stroke-width="10" opacity="0.22"/>
      `);
      paths.push(`
        <path class="trunk" filter="url(#glow)"
          d="M ${rootX} ${trunkTop}
             C ${rootX+2} ${trunkTop+40}, ${rootX-2} ${trunkBottom-40}, ${rootX} ${trunkBottom}"
          stroke-width="5" opacity="0.62"/>
      `);

      // links
      for(const item of nodes){
        const parent = item.node;
        for(const child of (parent.children || [])){
          const a = byId.get(parent.id);
          const b = byId.get(child.id);
          if(!a || !b) continue;

          const x1 = (a.x - minX) + CFG.padX;
          const y1 = (a.y) + CFG.padY;
          const x2 = (b.x - minX) + CFG.padX;
          const y2 = (b.y) + CFG.padY;

          // start from bottom of parent node, end at top of child node
          const startY = y1 + 46;
          const endY   = y2 - 46;

          const midY = (startY + endY) / 2;
          const bend = Math.max(40, Math.min(120, Math.abs(x2-x1)*0.35));

          const d = `
            M ${x1} ${startY}
            C ${x1} ${midY - bend}, ${x2} ${midY + bend}, ${x2} ${endY}
          `;

          // layered strokes: soft fat + sharp thin
          paths.push(`<path class="branch" filter="url(#softGlow)" d="${d}" stroke-width="8" opacity="0.14"/>`);
          paths.push(`<path class="branch" filter="url(#glow)" d="${d}" stroke-width="3.2" opacity="0.75"/>`);

          // tiny spark near child
          paths.push(`<circle class="spark" cx="${x2}" cy="${endY}" r="2.2" filter="url(#glow)"/>`);
        }
      }

      // subtle “mist” vignette
      const mist = `
        <rect x="0" y="0" width="100%" height="100%" fill="none"/>
      `;

      return defs + mist + paths.join("\n");
    }

    /***********************
     * 4) PAN + ZOOM
     ***********************/
    const viewport = document.getElementById("viewport");
    let view = { x: 60, y: 60, s: 1 };
    let dragging = false;
    let last = { x:0, y:0 };

    function applyTransform(){
      stage.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.s})`;
    }

    viewport.addEventListener("pointerdown", (e)=>{
      dragging = true;
      last = { x: e.clientX, y: e.clientY };
      viewport.setPointerCapture(e.pointerId);
    });
    viewport.addEventListener("pointermove", (e)=>{
      if(!dragging) return;
      const dx = e.clientX - last.x;
      const dy = e.clientY - last.y;
      last = { x: e.clientX, y: e.clientY };
      view.x += dx;
      view.y += dy;
      applyTransform();
    });
    viewport.addEventListener("pointerup", ()=>{
      dragging = false;
    });

    viewport.addEventListener("wheel", (e)=>{
      e.preventDefault();
      const delta = Math.sign(e.deltaY);
      const factor = delta > 0 ? 0.92 : 1.08;

      // zoom around cursor
      const rect = viewport.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;

      const beforeX = (cx - view.x) / view.s;
      const beforeY = (cy - view.y) / view.s;

      view.s = clamp(view.s * factor, 0.45, 2.2);

      const afterX = beforeX * view.s + view.x;
      const afterY = beforeY * view.s + view.y;

      view.x += (cx - afterX);
      view.y += (cy - afterY);

      applyTransform();
    }, { passive:false });

    function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

    document.getElementById("zoomIn").addEventListener("click", ()=>{
      view.s = clamp(view.s * 1.12, 0.45, 2.2);
      applyTransform();
    });
    document.getElementById("zoomOut").addEventListener("click", ()=>{
      view.s = clamp(view.s * 0.88, 0.45, 2.2);
      applyTransform();
    });

    document.getElementById("fit").addEventListener("click", fitToView);

    function fitToView(){
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;

      const sw = stage.offsetWidth;
      const sh = stage.offsetHeight;

      const scale = clamp(Math.min(vw / (sw + 120), vh / (sh + 120)), 0.45, 1.25);
      view.s = scale;
      view.x = (vw - sw*scale)/2;
      view.y = (vh - sh*scale)/2;
      applyTransform();
    }

    /***********************
     * 5) SEARCH
     ***********************/
    const searchInput = document.getElementById("search");
    let currentSearch = "";
    let matches = [];
    let matchIndex = 0;

    searchInput.addEventListener("input", (e)=>{
      currentSearch = e.target.value.trim();
      applySearchHighlight(currentSearch);
    });
    searchInput.addEventListener("keydown", (e)=>{
      if(e.key === "Enter" && matches.length){
        matchIndex = (matchIndex + 1) % matches.length;
        focusNode(matches[matchIndex]);
      }
      if(e.key === "Escape"){
        searchInput.value = "";
        currentSearch = "";
        applySearchHighlight("");
      }
    });

    function applySearchHighlight(q){
      document.querySelectorAll(".node").forEach(n => n.classList.remove("match"));
      matches = [];
      matchIndex = 0;
      if(!q || q.length < 2) return;

      const needle = q.toLowerCase();
      document.querySelectorAll(".node").forEach(el=>{
        const name = el.querySelector(".nameText")?.textContent || "";
        if(name.toLowerCase().includes(needle)){
          el.classList.add("match");
          matches.push(el);
        }
      });
      if(matches.length) focusNode(matches[0]);
    }

    function focusNode(el){
      const rect = el.getBoundingClientRect();
      const vp = viewport.getBoundingClientRect();
      const dx = (vp.left + vp.width/2) - (rect.left + rect.width/2);
      const dy = (vp.top  + vp.height/2) - (rect.top  + rect.height/2);
      view.x += dx;
      view.y += dy;
      applyTransform();
    }

    /***********************
     * 6) EDIT MODE + MODAL
     ***********************/
    let editMode = false;
    const toggleEditBtn = document.getElementById("toggleEdit");
    toggleEditBtn.addEventListener("click", ()=>{
      editMode = !editMode;
      document.body.classList.toggle("editing", editMode);
      toggleEditBtn.textContent = `Edit Mode: ${editMode ? "ON" : "OFF"}`;
      toggleEditBtn.classList.toggle("primary", !editMode);
    });

    const modalWrap = document.getElementById("modalWrap");
    const mName = document.getElementById("mName");
    const mTag = document.getElementById("mTag");
    const mNotes = document.getElementById("mNotes");
    const mSave = document.getElementById("mSave");
    const mCancel = document.getElementById("mCancel");
    const mDelete = document.getElementById("mDelete");
    const mAddChild = document.getElementById("mAddChild");
    const modalTitle = document.getElementById("modalTitle");

    let editingId = null;

    function openModal(id){
      const person = findById(treeData, id);
      if(!person) return;

      editingId = id;
      modalTitle.textContent = `Edit Person`;
      mName.value = person.name || "";
      mTag.value = person.tag || "";
      mNotes.value = person.notes || "";
      modalWrap.style.display = "flex";

      highlightSelected(id, true);
    }
    function closeModal(){
      modalWrap.style.display = "none";
      highlightSelected(editingId, false);
      editingId = null;
    }

    mCancel.addEventListener("click", closeModal);
    modalWrap.addEventListener("click", (e)=>{
      if(e.target === modalWrap) closeModal();
    });

    mSave.addEventListener("click", ()=>{
      if(!editingId) return;
      const person = findById(treeData, editingId);
      if(!person) return;

      person.name = mName.value.trim() || "Unnamed";
      person.tag  = mTag.value.trim();
      person.notes = mNotes.value.trim();

      saveData();
      render();
      closeModal();
    });

    mAddChild.addEventListener("click", ()=>{
      if(!editingId) return;
      const parent = findById(treeData, editingId);
      if(!parent) return;

      const childName = prompt("Child name?");
      if(!childName) return;

      const childTag = prompt("Tag/Role for this child? (optional)", "Child") || "";
      parent.children = parent.children || [];
      parent.children.push({ id: uid(), name: childName.trim(), tag: childTag.trim(), notes: "", children: [] });

      saveData();
      render();
    });

    mDelete.addEventListener("click", ()=>{
      if(!editingId) return;
      if(editingId === treeData.id){
        alert("You can’t delete the root person.");
        return;
      }
      if(!confirm("Delete this person and their branch?")) return;

      removeById(treeData, editingId);
      saveData();
      render();
      closeModal();
    });

    function highlightSelected(id, on){
      if(!id) return;
      const el = document.querySelector(`.node[data-id="${CSS.escape(id)}"]`);
      if(el) el.classList.toggle("selected", on);
    }

    function findById(node, id){
      if(!node) return null;
      if(node.id === id) return node;
      for(const c of (node.children || [])){
        const found = findById(c, id);
        if(found) return found;
      }
      return null;
    }

    function removeById(node, id){
      if(!node || !node.children) return false;
      const idx = node.children.findIndex(c => c.id === id);
      if(idx >= 0){
        node.children.splice(idx, 1);
        return true;
      }
      for(const c of node.children){
        if(removeById(c, id)) return true;
      }
      return false;
    }

    /***********************
     * 7) EXPORT / IMPORT
     ***********************/
    const saveState = document.getElementById("saveState");
    function setSaveBadge(text){
      saveState.textContent = text;
      saveState.style.borderColor = "rgba(74,208,199,0.30)";
      saveState.style.boxShadow = "0 0 0 3px rgba(74,208,199,0.12)";
      setTimeout(()=>{
        saveState.style.borderColor = "rgba(255,255,255,0.14)";
        saveState.style.boxShadow = "none";
      }, 900);
    }

    document.getElementById("exportBtn").addEventListener("click", ()=>{
      const blob = new Blob([JSON.stringify(treeData, null, 2)], { type:"application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "bhosale-family-tree.json";
      a.click();
      URL.revokeObjectURL(a.href);
    });

    document.getElementById("importBtn").addEventListener("click", ()=>{
      const inp = document.createElement("input");
      inp.type = "file";
      inp.accept = "application/json";
      inp.onchange = async ()=>{
        const file = inp.files?.[0];
        if(!file) return;
        const text = await file.text();
        try{
          const parsed = JSON.parse(text);
          treeData = sanitizeTree(parsed);
          saveData();
          render();
          fitToView();
          alert("Imported successfully!");
        }catch{
          alert("That file wasn’t valid JSON.");
        }
      };
      inp.click();
    });

    /***********************
     * 8) INIT
     ***********************/
    render();
    applyTransform();
    fitToView();
  </script>
</body>
</html>
