<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Family Tree</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#1b1b1b;
      --line:#2b2b2b;
      --boxStroke:#1f2937;

      /* Default box colors (can be changed in UI) */
      --blue:#b9d8ff;
      --red:#ffb7b7;

      --shadow: 0 10px 20px rgba(0,0,0,.08);
    }

    html,body{height:100%; margin:0;}
    body{
      background: var(--bg);
      color: var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    .wrap{
      width:min(1300px, 96vw);
      margin:0 auto;
      padding: 14px 12px 20px;
    }

    h1{
      text-align:center;
      margin: 6px 0 10px;
      font-size: 30px;
      letter-spacing: .3px;
      font-weight: 800;
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
      margin: 6px 0 14px;
    }

    .btn{
      background:#111;
      color:#fff;
      border:0;
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
      box-shadow: var(--shadow);
    }
    .btn.secondary{
      background:#fff;
      color:#111;
      border:1px solid rgba(0,0,0,.2);
      box-shadow:none;
    }

    .status{
      font-size: 13px;
      color: rgba(0,0,0,0.72);
      padding: 8px 10px;
      border: 1px dashed rgba(0,0,0,0.25);
      border-radius: 12px;
      background: rgba(0,0,0,0.03);
      min-width: 280px;
      text-align:center;
    }

    .picker{
      display:flex;
      gap:10px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(0,0,0,.02);
      font-size: 13px;
    }
    .picker label{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight: 700;
    }
    .picker input[type="color"]{
      width: 34px;
      height: 26px;
      border: 0;
      padding: 0;
      background: transparent;
      cursor: pointer;
    }

    .canvas{
      background:#fff;
      border:1px solid rgba(0,0,0,.10);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 14px 40px rgba(0,0,0,.08);
      height: min(78vh, 720px);   /* ✅ makes it fill page better */
      position: relative;
    }

    .hint{
      position:absolute;
      right: 10px;
      bottom: 10px;
      font-size: 12px;
      color: rgba(0,0,0,.65);
      background: rgba(255,255,255,.85);
      border: 1px solid rgba(0,0,0,.10);
      padding: 6px 8px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
    }

    svg{
      width:100%;
      height:100%;
      display:block;
      user-select:none;
      touch-action:none; /* allow custom panning on touch */
      background: #fff;
    }

    /* Nodes */
    .node-rect{
      stroke: var(--boxStroke);
      stroke-width: 1.8;
      rx: 10;
      ry: 10;
      cursor: pointer;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.08));
    }
    .node-text{
      font-weight: 750;
      font-size: 14px;
      fill: #111;
      dominant-baseline: middle;
      text-anchor: middle;
      pointer-events: none;
    }

    /* Edges */
    .edge{
      stroke: var(--line);
      stroke-width: 2;
      fill: none;
      opacity: .9;
    }

    /* Appear animation (top -> bottom) */
    .nodeGroup{
      opacity: 0;
      transform-origin: center;
      transform: translateY(-6px) scale(0.98);
    }
    .nodeGroup.show{
      opacity: 1;
      transform: translateY(0) scale(1);
      transition: opacity 500ms ease, transform 500ms ease;
    }
    .edge.hide{ opacity: 0; }
    .edge.show{
      opacity: 1;
      transition: opacity 420ms ease;
    }

    @media (prefers-reduced-motion: reduce){
      .nodeGroup{ opacity:1; transform:none; }
      .nodeGroup.show{ transition:none; }
      .edge.show{ transition:none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Family Tree</h1>

    <div class="controls">
      <button class="btn" id="saveBtn">Save</button>
      <button class="btn secondary" id="reloadBtn">Reload</button>
      <button class="btn secondary" id="animateBtn">Play Animation</button>

      <button class="btn secondary" id="fitBtn">Fit</button>
      <button class="btn secondary" id="zoomOutBtn">–</button>
      <button class="btn secondary" id="zoomInBtn">+</button>

      <div class="picker" title="Change box colors">
        <label>Blue <input type="color" id="blueColor" value="#b9d8ff"></label>
        <label>Red <input type="color" id="redColor" value="#ffb7b7"></label>
      </div>

      <div class="status" id="status">Loading…</div>
    </div>

    <div class="canvas" id="canvas">
      <svg id="svg" viewBox="0 0 1200 700" aria-label="Family tree diagram">
        <!-- Everything goes into this group so we can pan/zoom it -->
        <g id="viewport">
          <g id="edges"></g>
          <g id="nodes"></g>
        </g>
      </svg>
      <div class="hint">Drag to pan • Mouse wheel to zoom • Fit button</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    /************************************************************
     * EDIT THESE VALUES
     ************************************************************/
    const SUPABASE_URL = "https://rwpfasczbtkhjttidqog.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_tOi0MCMp7Fq96k4_VhAOrw_PoUKqIws";
    const TABLE_NAME = "family_tree";
    const TREE_ID = "bhosale";

    const statusEl = document.getElementById("status");
    const saveBtn = document.getElementById("saveBtn");
    const reloadBtn = document.getElementById("reloadBtn");
    const animateBtn = document.getElementById("animateBtn");

    const fitBtn = document.getElementById("fitBtn");
    const zoomInBtn = document.getElementById("zoomInBtn");
    const zoomOutBtn = document.getElementById("zoomOutBtn");

    const blueColor = document.getElementById("blueColor");
    const redColor = document.getElementById("redColor");

    const svg = document.getElementById("svg");
    const canvas = document.getElementById("canvas");
    const viewportG = document.getElementById("viewport");
    const edgesG = document.getElementById("edges");
    const nodesG = document.getElementById("nodes");

    const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    function defaultTree(){
      return {
        root: ["Bhahusaheb Bhosale", "Vasanti Bhosale"],
        children: [
          { name: "Anil Bhosale", spouse: "", kids: ["Tejaswini Bhosale","Shweta Bhosale","Atharva Bhosale"] },
          { name: "Satish Bhosale", spouse: "", kids: ["Aryan Bhosale"] },
          { name: "Manish Bhosale", spouse: "", kids: ["Swanandi Bhosale"] },
          { name: "Girish Bhosale", spouse: "", kids: ["Krish Bhosale","Parth Bhosale"] }
        ],
        colors: { blue: "#b9d8ff", red: "#ffb7b7" } // saved with tree
      };
    }

    let CURRENT = null;

    function setStatus(msg){ statusEl.textContent = msg; }

    /*************** Supabase load/save ***************/
    async function loadFromSupabase(){
      setStatus("Loading from Supabase…");
      const { data, error } = await db
        .from(TABLE_NAME)
        .select("data")
        .eq("id", TREE_ID)
        .single();

      if (error) {
        console.warn(error);
        CURRENT = defaultTree();
        applyColorsFromData();
        renderDiagram(CURRENT);
        fitToScreen();
        playAnimation();
        setStatus("Could not load row. Using defaults (you can still Save).");
        return;
      }

      CURRENT = (data && data.data) ? data.data : defaultTree();
      if (!CURRENT.colors) CURRENT.colors = { blue:"#b9d8ff", red:"#ffb7b7" };

      applyColorsFromData();
      renderDiagram(CURRENT);
      fitToScreen();
      playAnimation();
      setStatus("Loaded ✅ Click a box to edit.");
    }

    async function saveToSupabase(){
      if (!CURRENT) return;
      setStatus("Saving…");

      const { error } = await db
        .from(TABLE_NAME)
        .update({ data: CURRENT })
        .eq("id", TREE_ID);

      if (error) {
        console.error(error);
        setStatus("Save failed ❌ Open console (F12) to see the exact error.");
        alert("Save failed. Open console (F12) and copy the error message.");
        return;
      }
      setStatus("Saved ✅");
    }

    saveBtn.addEventListener("click", saveToSupabase);
    reloadBtn.addEventListener("click", loadFromSupabase);
    animateBtn.addEventListener("click", () => playAnimation(true));

    /*************** Color Picker ***************/
    function setCSSVar(name, value){
      document.documentElement.style.setProperty(name, value);
    }

    function applyColorsFromData(){
      const b = CURRENT?.colors?.blue || "#b9d8ff";
      const r = CURRENT?.colors?.red || "#ffb7b7";

      blueColor.value = b;
      redColor.value = r;

      setCSSVar("--blue", b);
      setCSSVar("--red", r);
    }

    blueColor.addEventListener("input", (e) => {
      const v = e.target.value;
      setCSSVar("--blue", v);
      if (!CURRENT.colors) CURRENT.colors = {};
      CURRENT.colors.blue = v;
      setStatus("Color changed (not saved yet). Click Save.");
    });

    redColor.addEventListener("input", (e) => {
      const v = e.target.value;
      setCSSVar("--red", v);
      if (!CURRENT.colors) CURRENT.colors = {};
      CURRENT.colors.red = v;
      setStatus("Color changed (not saved yet). Click Save.");
    });

    /*************** Diagram rendering ***************/
    const BOX_W = 150;
    const BOX_H = 42;
    const GAP_X = 24;
    const GAP_Y = 90;

    function nodeKey(type, a, b){
      return `${type}:${a}:${b ?? ""}`;
    }

    function renderDiagram(tree){
      edgesG.innerHTML = "";
      nodesG.innerHTML = "";

      const rootA = tree.root?.[0] ?? "Root A";
      const rootB = tree.root?.[1] ?? "Root B";

      const children = Array.isArray(tree.children) ? tree.children : [];
      const cols = Math.max(1, children.length);

      const unitW = (BOX_W * 2) + GAP_X;
      const totalW = cols * unitW + (cols - 1) * 50;
      const startX = (1200 - totalW) / 2;

      const rootY = 70;
      const rootX = 600 - (BOX_W + 16);

      const r1 = addNode(nodeKey("root",0), rootX, rootY, BOX_W, BOX_H, rootA, "blue");
      const r2 = addNode(nodeKey("root",1), rootX + BOX_W + 32, rootY, BOX_W, BOX_H, rootB, "red");

      // root marriage line
      addEdge({x:r1.x2, y:r1.cy}, {x:r2.x1, y:r2.cy});

      const rootMid = { x: (r1.cx + r2.cx) / 2, y: r1.cy };

      // stem down
      const stemTop = { x: rootMid.x, y: rootMid.y + (BOX_H/2) + 10 };
      const couplesY = rootY + GAP_Y;
      addEdge(stemTop, { x: stemTop.x, y: couplesY - 20 });

      // bus line across
      const busLeft = startX + (unitW/2);
      const busRight = startX + (cols-1)*(unitW + 50) + (unitW/2);
      addEdge({x:busLeft, y:couplesY-20}, {x:busRight, y:couplesY-20});

      // connect stem to bus (vertical)
      addEdge({x:stemTop.x, y:couplesY-20}, {x:stemTop.x, y:couplesY-20});

      const allNodeGroups = [];
      const allEdges = [];

      // helper to store edges as we create them
      function addEdgeTracked(a,b){
        const el = addEdge(a,b);
        allEdges.push(el);
        return el;
      }

      // track root nodes
      allNodeGroups.push(r1.group, r2.group);

      // rebuild edges with tracking
      edgesG.innerHTML = "";
      addEdgeTracked({x:r1.x2, y:r1.cy}, {x:r2.x1, y:r2.cy});
      addEdgeTracked(stemTop, { x: stemTop.x, y: couplesY - 20 });
      addEdgeTracked({x:busLeft, y:couplesY-20}, {x:busRight, y:couplesY-20});

      for(let i=0;i<cols;i++){
        const unitX = startX + i*(unitW + 50);

        const childName = children[i]?.name ?? "";
        const spouseName = children[i]?.spouse ?? "";
        const kids = Array.isArray(children[i]?.kids) ? children[i].kids : [];

        const c1 = addNode(nodeKey("child", i, "a"), unitX, couplesY, BOX_W, BOX_H, childName || "Name", "blue");
        const c2 = addNode(nodeKey("child", i, "b"), unitX + BOX_W + GAP_X, couplesY, BOX_W, BOX_H, spouseName || "Name", "red");
        allNodeGroups.push(c1.group, c2.group);

        // marriage line + drop from bus
        addEdgeTracked({x:c1.x2, y:c1.cy}, {x:c2.x1, y:c2.cy});
        const coupleMidX = (c1.cx + c2.cx)/2;
        addEdgeTracked({x:coupleMidX, y:couplesY-20}, {x:coupleMidX, y:couplesY});

        const kidsY0 = couplesY + GAP_Y;
        const kidGapY = 58;

        kids.forEach((kidName, k)=>{
          const kidY = kidsY0 + k * kidGapY;
          const kidX = unitX + (unitW/2) - (BOX_W/2);

          const kid = addNode(nodeKey("kid", i, k), kidX, kidY, BOX_W, BOX_H, kidName || "Name", (k%2===0 ? "blue":"red"));
          allNodeGroups.push(kid.group);

          if (k === 0){
            addEdgeTracked({x:coupleMidX, y:couplesY + BOX_H}, {x:coupleMidX, y:kidY});
          }
          addEdgeTracked({x:coupleMidX, y:kidY + (BOX_H/2)}, {x:kidX, y:kidY + (BOX_H/2)});
        });
      }

      window.__NODE_GROUPS__ = allNodeGroups;
      window.__EDGES__ = allEdges;
    }

    function addNode(key, x, y, w, h, text, colorMode){
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.classList.add("nodeGroup");
      g.dataset.key = key;

      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.classList.add("node-rect");
      rect.setAttribute("fill", colorMode === "red" ? "var(--red)" : "var(--blue)");
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width", w);
      rect.setAttribute("height", h);
      rect.addEventListener("click", () => editNode(key));

      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.classList.add("node-text");
      t.setAttribute("x", x + w/2);
      t.setAttribute("y", y + h/2);
      t.textContent = text;

      g.appendChild(rect);
      g.appendChild(t);
      nodesG.appendChild(g);

      return {
        group: g,
        x1: x, x2: x+w,
        y1: y, y2: y+h,
        cx: x+w/2,
        cy: y+h/2
      };
    }

    function addEdge(a, b){
      const p = document.createElementNS("http://www.w3.org/2000/svg","path");
      p.classList.add("edge", "hide");
      const midY = (a.y + b.y)/2;
      p.setAttribute("d", `M ${a.x} ${a.y} L ${a.x} ${midY} L ${b.x} ${midY} L ${b.x} ${b.y}`);
      edgesG.appendChild(p);
      return p;
    }

    function editNode(key){
      if (!CURRENT) return;
      const parts = key.split(":");
      const type = parts[0];

      if (type === "root"){
        const idx = parseInt(parts[1], 10);
        const prev = CURRENT.root?.[idx] ?? "";
        const next = prompt("Edit name:", prev);
        if (next === null) return;
        CURRENT.root[idx] = next;
        renderDiagram(CURRENT);
        playAnimation(false);
        setStatus("Edited (not saved yet). Click Save.");
        return;
      }

      if (type === "child"){
        const i = parseInt(parts[1], 10);
        const side = parts[2];
        const prev = side === "b" ? (CURRENT.children[i].spouse || "") : (CURRENT.children[i].name || "");
        const next = prompt("Edit name:", prev);
        if (next === null) return;
        if (side === "b") CURRENT.children[i].spouse = next;
        else CURRENT.children[i].name = next;
        renderDiagram(CURRENT);
        playAnimation(false);
        setStatus("Edited (not saved yet). Click Save.");
        return;
      }

      if (type === "kid"){
        const i = parseInt(parts[1], 10);
        const k = parseInt(parts[2], 10);
        const prev = CURRENT.children[i]?.kids?.[k] ?? "";
        const next = prompt("Edit name:", prev);
        if (next === null) return;
        CURRENT.children[i].kids[k] = next;
        renderDiagram(CURRENT);
        playAnimation(false);
        setStatus("Edited (not saved yet). Click Save.");
      }
    }

    /*************** Animation ***************/
    function playAnimation(reset = true){
      const groups = window.__NODE_GROUPS__ || [];
      const edges = window.__EDGES__ || [];

      if (reset){
        groups.forEach(g => g.classList.remove("show"));
        edges.forEach(e => { e.classList.remove("show"); e.classList.add("hide"); });
      }

      let delay = 0;
      const step = 130;

      groups.forEach((g)=>{
        setTimeout(() => g.classList.add("show"), delay);
        delay += step;
      });

      let edgeDelay = step * 2;
      edges.forEach((e)=>{
        setTimeout(() => { e.classList.remove("hide"); e.classList.add("show"); }, edgeDelay);
        edgeDelay += 55;
      });
    }

    /*************** Pan + Zoom + Fit ***************/
    let scale = 1;
    let panX = 0;
    let panY = 0;

    function applyTransform(){
      viewportG.setAttribute("transform", `translate(${panX}, ${panY}) scale(${scale})`);
    }

    function fitToScreen(){
      // Fit the diagram bounds into available canvas
      const bbox = viewportG.getBBox();
      const cw = canvas.clientWidth;
      const ch = canvas.clientHeight;

      // padding
      const pad = 24;

      const sx = (cw - pad*2) / bbox.width;
      const sy = (ch - pad*2) / bbox.height;
      scale = Math.max(0.3, Math.min(1.6, Math.min(sx, sy)));

      // center
      panX = (cw/2) - (bbox.x + bbox.width/2) * scale;
      panY = (ch/2) - (bbox.y + bbox.height/2) * scale;

      applyTransform();
    }

    fitBtn.addEventListener("click", fitToScreen);
    zoomInBtn.addEventListener("click", () => { scale = Math.min(2.4, scale + 0.1); applyTransform(); });
    zoomOutBtn.addEventListener("click", () => { scale = Math.max(0.2, scale - 0.1); applyTransform(); });

    // Mouse wheel zoom
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = Math.sign(e.deltaY);
      const factor = (delta > 0) ? 0.92 : 1.08;
      scale = Math.max(0.2, Math.min(3, scale * factor));
      applyTransform();
    }, { passive:false });

    // Drag to pan
    let dragging = false;
    let lastX = 0, lastY = 0;

    canvas.addEventListener("pointerdown", (e) => {
      dragging = true;
      canvas.setPointerCapture(e.pointerId);
      lastX = e.clientX;
      lastY = e.clientY;
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      panX += dx;
      panY += dy;
      applyTransform();
    });

    canvas.addEventListener("pointerup", () => { dragging = false; });
    canvas.addEventListener("pointercancel", () => { dragging = false; });

    // Start
    loadFromSupabase();
    window.addEventListener("resize", () => { if (CURRENT) fitToScreen(); });
  </script>
</body>
</html>
